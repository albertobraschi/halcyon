#!/usr/bin/env ruby -wKU
#--
#  Created by Matt Todd on 2007-10-25.
#  Copyright (c) 2007. All rights reserved.
#++

# Blatantly stolen from Chris Neukirchen's rackup utility for running Rack
# apps. (Forgive me, it just made too much sense to use your Rack bootstrap
# code for my Rack bootstrap.)

#--
# dependencies
#++

%w(optparse).each{|dep|require dep}

#--
# default options
#++

options = {
  :environment => 'none',
  :port => 9267,
  :host => 'localhost',
  :server => 'mongrel',
  :log_file => '/tmp/halcyon.log'
}

#--
# parse options
#++

opts = OptionParser.new("", 24, '  ') do |opts|
  opts.banner << "Halcyon, JSON Server Framework\n"
  opts.banner << "http://halcyon.rubyforge.org/\n"
  opts.banner << "\n"
  opts.banner << "Usage: halcyon [options] appname"
  
  opts.separator ""
  opts.separator "Options:"
  
  opts.on("-d", "--debug", "set debugging flags (set $debug to true)") { $debug = true }
  opts.on("-w", "--warn", "turn warnings on for your script") { $-w = true }
  
  opts.on("-I", "--include PATH", "specify $LOAD_PATH (may be used more than once)") do |path|
    $:.unshift(*path.split(":"))
  end
  
  opts.on("-r", "--require LIBRARY", "require the library, before executing your script") do |library|
    require library
  end
  
  opts.on("-c", "--config PATH", "configuration stored in PATH") do |conf|
    options[:config_file] = conf
  end
  
  opts.on("-s", "--server SERVER", "serve using SERVER (default: #{options[:server]})") do |serv|
    options[:server] = serv
  end
  
  opts.on("-o", "--host HOST", "listen on HOST (default: #{options[:host]})") do |host|
    options[:host] = host
  end
  
  opts.on("-p", "--port PORT", "use PORT (default: #{options[:port]})") do |port|
    options[:port] = port
  end
  
  opts.on("-l", "--logfile PATH", "log access to PATH (default: #{options[:log_file]})") do |log_file|
    options[:log_file] = log_file
  end
  
  opts.on("-e", "--env ENVIRONMENT", "use ENVIRONMENT for defaults (default: #{options[:environment]})") do |env|
    options[:environment] = env
  end
  
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
  
  opts.on_tail("-v", "--version", "Show version") do
    # require 'halcyon'
    puts "Halcyon #{Halcyon::Server.version}"
    exit
  end
  
  begin
    opts.parse! ARGV
  rescue OptionParser::InvalidOption => e
    abort "You used an unsupported option. Try: halcyon -h"
  end
end

abort "Halcyon needs an app to run. Try: halcyon -h" if ARGV.empty? 
options[:app] = ARGV.shift

#--
# load dependencies
#++

%w(rubygems rack).each{|dep|require dep}

$:.unshift '/Users/mtodd/Sites/halcyon/trunk/lib/'
%w(halcyon/server).each {|dep|require dep}

#--
# load app
#++

if !File.exists?("#{options[:app]}.rb")
  abort "Halcyon did not find the app #{options[:app]}. Check your path and try again."
end

require options[:app]
app = Object.const_get(File.basename(options[:app]).capitalize.gsub(/_([a-z])/){|m|m[1].chr.capitalize})

#--
# prepare server
#++

require options[:server]
server = Rack::Handler.const_get(options[:server].capitalize)

#--
# prepare app environment
#++

case options[:environment]
when "development"
  app = Rack::Builder.new {
    use Rack::CommonLogger, STDERR  unless server.name =~ /CGI/
    use Rack::ShowExceptions
    use Rack::Reloader
    use Rack::Lint
    run app.new(options)
  }.to_app
when "deployment"
  app = Rack::Builder.new {
    use Rack::CommonLogger, STDERR  unless server.name =~ /CGI/
    run app.new(options)
  }.to_app
else
  app = app.new(options)
end

#--
# start server
#++

server.run app, :Port => options[:port]
