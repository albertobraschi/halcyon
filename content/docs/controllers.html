---
title:  Docs &mdash; Writing Controllers
layout: simple
filter:
  - erb
  - textile
---

h2. Writing Controllers

Controllers are the functional heart of your application. Requests to your
application get routed to controllers where the actions defined within them are
dispatched.

Those of you familiar with "Rails":http://rubyonrails.org/ or "MVC":http://wikipedia.org/wiki/Model-view-controller
in general will recognize the role that the controller and its actions play.
While the models will contain the primary portion of logic, controllers will
coordinate it all.

Really, there's nothing special about Halcyon controllers. Let's look at what
they look like.


h3. Controller Structure

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
class Messages < Application
  
  def show
    ok Message[params[:id]]
  end
  
end
<% end -%>

The @Application@ class we inherit from simply from @Halcyon::Controller@ and 
provides a place for utility methods et al. @Application@ is created by default
when generating an application.


h3. Actions

Actions make up the functional portion of classes. Actions are considered any
public method (private methods are not callable through routes).

Actions have several useful methods, two of which will be used in most actions:
@params@ and @ok@. The @params@ method provides access to the parameters
available, such as GET params, POST params, and route params. @ok@ is used to
format responses and is akin to calling @render :json => val@ in Rails.


h3. Resources

The "REST":http://wikipedia.org/wiki/REST approach to application design treats
our models as resources with a standard set of methods to work them them.
Again, if you're familiar with Rails development, none of this is new. Here is
an example controller defining these standard REST methods.

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
class Messages < Application
  
  def show
    ok Message[params[:id]]
  end
  
  def create
    ok Message << params
  end
  
  def update
    Message.filter(:id => params[:id]).update(params)
    ok
  end
  
  def delete
    Message.filter(:id => params[:id]).delete
    ok
  end
  
end
<% end -%>

Resources are mapped to these methods through routing method @resource@. This
is one of the benefits of using the "Merb":http://merbivore.com/ router.

Read more about "writing routes":/docs/routes.html for great coverage of this
topic.


h3. Error Handling and Exceptions

There will inevitably be errors that need to be handled and exceptions are a
big part of gracefully working with errors in a meaningful way. Halcyon
provides all of the standard HTTP responses as exceptions to help with quickly
communicating the appropriate status of a request, and Halcyon handles
exceptions to gracefully communicate with the client the appropriate status in
the standard format.

Here is an example of handling success or failure:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
class Messages < Application
  
  def show
    if (msg = Message[params[:id]])
      ok msg
    else
      raise NotFound.new
    end
  end
  
  def create
    msg = Message.new
    msg.values.merge! params
    if (id = msg.save)
      ok id
    else
      raise UnprocessableEntity.new
    end
  end
  
end
<% end -%>

The @UnprocessableEntity@ exception class maps directly to the standard HTTP
response code @422 Unprocessable Entity@ which signifies that there were errors
creating the record as the models validations failed. You can certainly supply
the exception with a body other than the literal text @"Unprocessable Entity"@
which could be the exact error (which is recommended). This is up to you, of
course.

Check out the "list of exceptions":/docs/exceptions.html to see what's
available and how to use them.
