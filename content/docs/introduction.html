---
title:  Docs &mdash; Introduction to Halcyon
layout: simple
filter:
  - erb
  - textile
---
h2. Introduction to Halcyon

Halcyon is a simple framework to ease development of service-oriented applications, such as public or private APIs or custom services for applications.


h3. Conception

Halcyon started off as a centralized authentication system for numerous applications on varied platforms, at the time called Aurora. The decision was made to split Aurora into a framework and an application, Halcyon becoming the framework.


h3. The Framework

As a framework, Halcyon breaks your application code up into controllers with absolutely no views and no predefined system for models or database connectivity. Routes are used to define what paths are handled by what actions in which controllers.


h4. Controllers

Halcyon's controllers all inherit from Halcyon::Controller which provides several useful methods for responding in different situations, such as the @ok@ method to respond with the @200 OK@ standard HTTP success response, along with any data you need to send back.

For example, a controller may look like this:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
class Messages < Application
  def new
    # respond with fields acceptable
    ok [:body, :title, :tags]
  end
  def create
    case method
    when :post
      DB[:messages] << params.merge(:tags => params[:tags].join)
      ok
    when :get
      # the params required for new messages
      ok [:message, :tags]
    else
      raise NotImplemented
    end
  end
  def read
    ok DB[:messages][params[:id]]
  end
  def update
    case method
    when :post
      DB[:messages].filter(:id => params[:id]).update(params)
      ok
    else
      raise NotImplemented
    end
  end
  def delete
    DB[:messages].filter(:id => params[:id]).delete
    ok
  end
end
<% end -%>

@DB@ refers to a "Sequel":http://code.google.com/p/ruby-sequel/ connection, which lets us talk to the @messages@ table. This could just as easily be a Sequel model, ActiveRecord model, or DataMapper model.

Read more about "Writing Controllers":/docs/controllers.html


h4. Routes

Part of developing a Halcyon app is writing the controllers, but requests need to be routed to the appropriate actions.

There are, by default, no routes defined for an application, but there is a way to quickly define routes as matching any variation of @/:controller/:action/:id@, etc. For example:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
Halcyon::Application.route do |r|
  r.default_routes
end
<% end -%>

Of course, you can add to the default routes with custom routes, like so:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
Halcyon::Application.route do |r|
  r.match('/api/:version/:controller/:action(/:id)?').to()
  r.default_routes
end
<% end -%>

Read more about "Defining Routes":/docs/routes.html.


h4. Clients

The easiest way to communicate with your Halcyon application is with a Halcyon client. By default, it creates a simple way to perform GET, POST, PUT, and DELETE requests on application routes, but can be extended with methods that easily corresponds with your routes. For example:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
>> class MessageClient < Halcyon::Client
*>   def create(params)
*>     post("/api/1.0/messages/create", params)
*>   end
*> end
>> Message = MessageClient.new('http://localhost:4647/')
=> #<MessageClient>
>> Message.create(:message => 'First test.', :tags => ['test', 'first'])
=> {'status' => 200, 'body' => {:id => 1}}
>> Message.post("/api/1.0/messages/create", :message => 'Second test.', :tags => [])
=> {'status' => 200, 'body' => {:id => 2}}
<% end -%>

You can also implement clients into your currently existing models.

Read more about "Customizing Clients":/docs/clients.html
