---
title:  Docs &mdash; Defining Routes
layout: simple
filter:
  - erb
  - textile
---

h2. Defining Routes

One of the most peculiar parts of Halcyon is its dependency on
"Merb":http://merbivore.com/, but this is for a very good reason: Merb provides
a great deal of great code that is modular and clean, perfect to implement into
Halcyon. This has two affects: first, those pieces of code are very well
documented by a very large and active community, and secondly is that they are
continually being updated to better perform. Rewriting what Merb has already
done would be silly. *So when it comes to defining routes in Halcyon, much of
the documentation for defining routes in Merb still applies!*

For links to various Routing documentation for Merb, jump to the bottom of the
page and look under the Resources section.


h3. Getting Started

Routes are defined in @app_name/config/init/routes.rb@, wherein you will find
something like this by default:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
# = Routes
Halcyon::Application.route do |r|
  
  # Sample route for the sample functionality in Application.
  # Safe to remove!
  r.match('/time').to(:controller => 'application', :action => 'time')
  
  # RESTful routes
  # r.resources :posts
  
  # This is the default route for /:controller/:action/:id
  # This is fine for most cases.  If you're heavily using resource-based
  # routes, you may want to comment/remove this line to prevent
  # clients from calling your create or destroy actions with a GET
  r.default_routes
  
  # Change this for the default route to be available at /
  r.match('/').to(:controller => 'application', :action => 'index')
  # It can often be useful to respond with available functionality if the
  # application is a public-facing service.
  
  # Default not-found route
  {:action => 'not_found'}
  
end
<% end -%>

In the lower half you see where two routes are defined and one failover route
is specified. (This failover route is actually set by default, but it is
provided here as well to indicate how to update this default easily).

Within the @route@ block, @r@ is used to define what routes to match against
and where to route those requests to. Routes can be very specific or very
general, accepting no or many variables in the route itself. Here are several
examples to hopefully clarify the flexibility of these routes:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
r.match('/api/:version/app_name/:controller/:action').to()
r.match('/:controller/:action/:id').to()
r.match('/:controller/:action').to()
r.match('/time').to(:controller => 'utilities', :action => 'time')
r.match('/').to(:controller => 'application', :action => 'usage')
<% end -%>

The @default_routes@ method is also one provided for by Merb and can also
provide extra functionality as well as clarifies some other useful methods like
@defer_to@ for conditional routes. Read below in the Links section for more
information.


h3. Resources

One of the more power routing mechanics is the definition of resources which
map to "REST":http://wikipedia.org/wiki/REST functionality through standard
actions (discussed in the "writing controllers":/docs/controllers.html
article).

Defining resources' routes is trivial and the routes that are defined doing so
should cover most uses of a given resource (with the ability to define extended
functionality with the rest of the Merb routes API). Here's an example of
defining a resource route:

<% coderay(:lang => "ruby", :line_numbers => "inline", :tab_width => 2) do -%>
Halcyon::Application.route do |r|
  
  r.resources :messages
  
end
<% end -%>

Here are the routes that get generated with this:

<code><pre>
GET /messages
POST /messages
GET /messages/:id
PUT /messages/:id
DELETE /messages/:id
</pre></code>

These effectively map to the the @list@, @create@, @show@, @update@, and
@delete@ actions in the @Messages@ controller, respectively. It's important to
note that the controller it expects is the camel case of the resource. It's
also an acceptable (and possibly even recommended) practice to name your model
the singular form, thereby having the @Message@ resource mapped to the
@Messages@ resource controller. This provides a very sane mental mapping when
working with the code.


h3. Links

Merb's API provides two very useful resources for defining routes. These two
are the methods used to match paths and define how to handle those routes.
These links are:

* "Merb::Router::Behavior#match":http://merbivore.com/documentation/merb-core/head/index.html?a=M000787&name=match
* "Merb::Router::Behavior#to":http://merbivore.com/documentation/merb-core/head/index.html?a=M000790&name=to

The @Merb::Router::Behavior@ class is used to generate each route, which you
will recognize it as the block parameter passed and used similar to
@r.match('/').to(:controller => 'application', :action => 'index')@.

Also, the "Merb::Router::Behavior#default_routes":http://merbivore.com/documentation/merb-core/head/index.html?a=M000792&name=default_routes
method may be worth investigating as it handles defining common routes like
@/:controller/:action/:id@ and the like.

Merb provides documentation for the @resources@ route definition as well at
"Merb::Router::Behavior#resources":http://merbivore.com/documentation/merb-core/head/index.html?a=M000998&name=resources.

Check out these other great links as well:

* "An Introduction to Routing":http://merbunity.com/tutorials/12 at "Merbunity":http://merbunity.com/
* "Routing":http://wiki.merbivore.com/pages/routing at the "Merb Wiki":http://wiki.merbivore.com/
